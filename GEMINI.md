## Project Overview

This project, `generalized_landcovers` (also known as `OpenLandcoverMap`), is designed to create generalized landcover maps from OpenStreetMap (OSM) data, specifically for zoom levels z0-z8. The standard OSM map can appear empty at these zoom levels, and this project aims to provide a more visually informative map by generalizing landcover features.

The core idea is to use a hexagonal grid (H3) to process OSM data. For each cell in the grid, the project identifies the dominant landcover type based on the area it covers. These cells are then merged to create larger, generalized polygons, which are then styled and rendered into map tiles.

The project uses a combination of technologies:

*   **PostGIS:** A PostgreSQL extension for storing and processing geospatial data.
*   **H3:** A hexagonal hierarchical spatial index.
*   **Mapnik:** A toolkit for rendering maps.
*   **Python:** Used for various scripting and data processing tasks.
*   **Make:** For orchestrating the build and data processing pipeline.

## Next Steps

Prioritized via MoSCoW method:

### Must
*  **Add legend to the map.**  The most common complain is that the map legend is missing. We need to somehow add rendering samples to both **renderedtags.html** and  **index.html**

### Should
*  **Migrate to vector tiles** (See the 'Plan: Modernize the Rendering Stack' secton below)

### Could
None

### Would Not
None



## Building and Running

The project uses a `makefile` to manage the build process. Here are the key commands:

*   `make all`: This is the default command. It runs the entire data processing pipeline, which includes:
    *   Creating tables in the PostGIS database.
    *   Generating shapefiles from the database tables.
    *   Creating a `mapnik.xml` file from the `.mml` and `.mss` style files.
    *   Generating MBTiles for the final map.
*   `make test`: Runs a test script (`test.py`) that likely renders a sample map and compares it to a reference image to ensure the output is correct.
*   `make clean`: Removes generated files and drops the `h3` schema from the PostGIS database.
*   `make import_planet`: Imports a full OpenStreetMap planet file into the PostGIS database. This is a long-running process.
*   `make update_db`: Updates the PostGIS database with the latest changes from OpenStreetMap.

## Development Conventions

*   **Build Process:** The entire build and data processing pipeline is managed by the `makefile`.
*   **Data Processing:** The core generalization logic is implemented in SQL scripts, which are located in the `sql-scripts/` directory. These scripts are executed by `psql` commands in the `makefile`.
*   **Styling:** The map's visual appearance is defined in `.mss` (Map Style Sheet) files. These are compiled into a `mapnik.xml` file using the `carto` tool.
*   **Map Layers:** The `project.mml` file defines the layers of the map, referencing the shapefiles generated by the data processing pipeline.
*   **Scripting:** Python scripts are used for various helper tasks, such as generating taginfo JSON and creating HTML pages.

## Plan: Modernize the Rendering Stack

The goal is to enhance the interactive web map by switching to vector tiles, while continuing to provide Shapefiles as a primary download artifact. This plan outlines a dual-output strategy.

### Dual-Artifact Approach

The project will produce two sets of outputs:
1.  **Shapefiles (`.shp`):** For download and use in desktop GIS software. The generation process for these remains unchanged.
2.  **Vector Tiles (`.mvt`):** For a fast and interactive web map. This is a new addition to the workflow.

### High-Level Migration Plan

1.  **Preserve Shapefile Generation:** The existing targets in the `makefile` that use `ogr2ogr` to create Shapefiles from PostGIS tables will be kept as is. The process of creating downloadable `.zip` archives will also remain.

2.  **Add Vector Tile Generation:**
    *   New targets will be added to the `makefile`.
    *   These targets will read from the same final PostGIS tables (e.g., `h3.landcovers_aggr`, `h3.places`).
    *   They will use PostGIS's built-in `ST_AsMVT()` function to generate Mapbox Vector Tiles (`.mvt`) directly from the database.
    *   The output tiles will be stored in a separate directory, such as `data/tiles/{z}/{x}/{y}.mvt`.

3.  **Implement Client-Side Rendering:**
    *   A lightweight tile-server can be set up to serve the newly generated `.mvt` files.
    *   The web map interface will be updated to use a client-side rendering library like **MapLibre GL JS**.
    *   A new JSON-based style file will be created to define the map's appearance, replacing the need for `.mss` files for the web map.

4.  **Update Build Workflow:**
    *   The parts of the `makefile` responsible for rendering **raster tiles for the web map** (i.e., using `carto` and `node ../tilemill/index.js` to create PNGs/MBTiles) can be deprecated and removed.
    *   The Shapefile generation workflow remains fully intact.

This approach ensures that the project's existing functionality is preserved while adding the significant benefits of a modern, vector-tile-based web map.

## Feature: Empty Hex Viewer

### User Request

> я хочу следующую фунциональность. Чтобы была html страница, котороя показывала бы cлучайный пустой гекс (т.е. тот, который в результате генерализации остался белым, не пройдя порог (1%), этот гекс бы рисовался на карте поверх подложки osm (или спутник бинг, на выбор), показывалась бы стастистика сколько и каких landcovers нарисовано, а так же ссылки: редактировать  в josm/ редактировать в id.
>
> Стек технологий: html/css/js + python/postgress, т.е. то что уже есть в проекте. Необходимые таблицы с гексами и статистикой найди сам.
>
> не правь код, представь план.

### Plan

**Цель:** Создать веб-страницу, которая поможет выявлять и анализировать области с разнообразным, но не доминирующим покрытием, которые не попали в итоговую карту. Это позволит улучшать качество данных в OpenStreetMap.

**Шаг 1: Бэкенд — скрипт для извлечения данных**

1.  **Поиск "пустых" гексов:**
    *   Я напишу SQL-запрос, который будет находить гексы, присутствующие в таблице с исходными данными (`h3.h3_landuse_overlay`), но отсутствующие в итоговой сгенерированной таблице `h3.landcovers_aggr`. Это и будут наши "пустые" гексы, где ни один тип покрытия не превысил порог для генерализации.
2.  **Создание Python-скрипта (`get_random_empty_hex.py`):**
    *   Этот скрипт будет подключаться к базе данных PostGIS.
    *   Он выполнит SQL-запрос для выбора одного **случайного** "пустого" гекса.
    *   Для этого гекса скрипт запросит из базы детальную статистику: список всех типов `landcover`, которые в нем присутствуют, и площадь, которую каждый из них занимает.
    *   Скрипт также получит геометрию гекса в формате GeoJSON.
    *   Вся информация (ID гекса, статистика, геометрия, центр гекса) будет сохранена в один статический файл `empty_hex_data.json`. Этот файл будет использоваться фронтендом.

**Шаг 2: Фронтенд — страница для визуализации**

1.  **Создание HTML-страницы (`empty_hex.html`):**
    *   Я создам новый файл `webui-prototypes/empty_hex.html`.
    *   На эту страницу я добавлю библиотеку для отображения интерактивных карт, например, **Leaflet.js**, так как она легкая и простая в использовании.
2.  **Написание JavaScript-кода:**
    *   Скрипт на странице будет асинхронно загружать данные из созданного на первом шаге файла `empty_hex_data.json`.
    *   **Карта:** Будет инициализирована карта Leaflet, сфокусированная на координатах центра гекса. На карту будут добавлены два слоя-подложки на выбор: OpenStreetMap и спутниковые снимки Bing.
    *   **Визуализация:** Геометрия гекса будет отрисована на карте как полигон.
    *   **Статистика:** Данные о типах покрытия и их площади будут выведены на странице в виде наглядной таблицы или списка.
    *   **Ссылки для редактирования:** Будут сгенерированы и показаны две ссылки: "Редактировать в JOSM" и "Редактировать в iD", которые будут открывать выбранную область в соответствующем редакторе OSM.

**Шаг 3: Интеграция в проект**

1.  **Обновление `makefile`:**
    *   Я добавлю в `makefile` новую цель, например, `show_empty_hex`. Эта команда будет запускать Python-скрипт из Шага 1 для генерации актуального `empty_hex_data.json` и затем открывать страницу `empty_hex.html` в браузере.
